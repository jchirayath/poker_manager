import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../../core/services/supabase_service.dart';
import '../../../../shared/models/result.dart';
import '../models/settlement_model.dart';
import '../../../games/data/models/game_participant_model.dart';

class SettlementsRepository {
  final SupabaseClient _client = SupabaseService.instance;

  Future<Result<SettlementValidation>> validateSettlement(String gameId) async {
    try {
      final response = await _client
          .from('game_participants')
          .select('total_buyin, total_cashout')
          .eq('game_id', gameId);

      double totalBuyins = 0;
      double totalCashouts = 0;

      for (var p in response) {
        totalBuyins += (p['total_buyin'] ?? 0).toDouble();
        totalCashouts += (p['total_cashout'] ?? 0).toDouble();
      }

      final difference = totalBuyins - totalCashouts;
      const tolerance = 0.01;

      final validation = SettlementValidation(
        isValid: difference.abs() <= tolerance,
        totalBuyins: totalBuyins,
        totalCashouts: totalCashouts,
        difference: difference,
        message: difference.abs() <= tolerance
            ? 'Buy-ins and cash-outs match!'
            : 'Warning: Buy-ins (\${totalBuyins.toStringAsFixed(2)}) '
                'do not match cash-outs (\${totalCashouts.toStringAsFixed(2)}). '
                'Difference: \${difference.toStringAsFixed(2)}',
      );

      return Result.success(validation);
    } catch (e) {
      return Result.failure('Validation failed: ${e.toString()}');
    }
  }

  Future<Result<List<SettlementModel>>> calculateSettlement(
      String gameId) async {
    try {
      // Get all participants with their net positions
      final participantsResponse = await _client
          .from('game_participants')
          .select('*, profile:profiles(first_name, last_name)')
          .eq('game_id', gameId);

      final participants =
          (participantsResponse as List).map((json) {
        return GameParticipantModel.fromJson(json);
      }).toList();

      // Separate into creditors (net positive) and debtors (net negative)
      final creditors = <Map<String, dynamic>>[];
      final debtors = <Map<String, dynamic>>[];

      for (var p in participants) {
        if (p.netResult > 0.01) {
          creditors.add({
            'userId': p.userId,
            'name': p.profile != null
                ? '${p.profile!.firstName} ${p.profile!.lastName}'
                : 'Unknown',
            'amount': p.netResult,
          });
        } else if (p.netResult < -0.01) {
          debtors.add({
            'userId': p.userId,
            'name': p.profile != null
                ? '${p.profile!.firstName} ${p.profile!.lastName}'
                : 'Unknown',
            'amount': p.netResult.abs(),
          });
        }
      }

      // Sort creditors descending, debtors descending
      creditors.sort((a, b) => (b['amount'] as double).compareTo(a['amount'] as double));
      debtors.sort((a, b) => (b['amount'] as double).compareTo(a['amount'] as double));

      // Calculate optimal settlements using greedy algorithm
      final settlements = <SettlementModel>[];
      int i = 0, j = 0;

      while (i < creditors.length && j < debtors.length) {
        final creditor = creditors[i];
        final debtor = debtors[j];

        final creditorAmount = creditor['amount'] as double;
        final debtorAmount = debtor['amount'] as double;

        final paymentAmount = creditorAmount < debtorAmount
            ? creditorAmount
            : debtorAmount;

        // Create settlement
        final settlement = SettlementModel(
          id: '', // Will be generated by database
          gameId: gameId,
          payerId: debtor['userId'] as String,
          payeeId: creditor['userId'] as String,
          amount: paymentAmount,
          status: 'pending',
          payerName: debtor['name'] as String,
          payeeName: creditor['name'] as String,
        );

        settlements.add(settlement);

        // Update amounts
        creditor['amount'] = creditorAmount - paymentAmount;
        debtor['amount'] = debtorAmount - paymentAmount;

        // Move to next creditor or debtor
        if (creditor['amount'] <= 0.01) i++;
        if (debtor['amount'] <= 0.01) j++;
      }

      // Save settlements to database
      if (settlements.isNotEmpty) {
        // Delete existing settlements for this game
        await _client.from('settlements').delete().eq('game_id', gameId);

        // Insert new settlements
        final settlementsData = settlements
            .map((s) => {
                  'game_id': s.gameId,
                  'payer_id': s.payerId,
                  'payee_id': s.payeeId,
                  'amount': s.amount,
                  'status': s.status,
                })
            .toList();

        await _client.from('settlements').insert(settlementsData);
      }

      return Result.success(settlements);
    } catch (e) {
      return Result.failure('Settlement calculation failed: ${e.toString()}');
    }
  }

  Future<Result<List<SettlementModel>>> getGameSettlements(
      String gameId) async {
    try {
      final response = await _client
          .from('settlements')
          .select('''
            *,
            payer:profiles!settlements_payer_id_fkey(first_name, last_name),
            payee:profiles!settlements_payee_id_fkey(first_name, last_name)
          ''')
          .eq('game_id', gameId);

      final settlements = (response as List).map((json) {
        return SettlementModel.fromJson({
          ...json,
          'payerName': json['payer'] != null
              ? '${json['payer']['first_name']} ${json['payer']['last_name']}'
              : null,
          'payeeName': json['payee'] != null
              ? '${json['payee']['first_name']} ${json['payee']['last_name']}'
              : null,
        });
      }).toList();

      return Result.success(settlements);
    } catch (e) {
      return Result.failure('Failed to load settlements: ${e.toString()}');
    }
  }

  Future<Result<void>> markSettlementComplete(String settlementId) async {
    try {
      await _client.from('settlements').update({
        'status': 'completed',
        'completed_at': DateTime.now().toIso8601String(),
      }).eq('id', settlementId);

      return const Result.success(null);
    } catch (e) {
      return Result.failure('Failed to mark settlement complete: ${e.toString()}');
    }
  }
}
